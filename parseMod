#!/usr/bin/env python

# Parse module load log files created and count what modules
# were called via parsing lines with 'module-hpc'. 
# Arguments:  list of files to process, if empty use all /var/log/module-hpc* files

import sys
import os
from collections import defaultdict
from getModInfo import ModInfo

class  FileParser:
    def __init__(self, args):
        self.prog = os.path.basename(args[0])
        self.args = args[1:]          # command line arguments
        self.basedir = "/var/log/"    # default directory for log files
        self.files = []               # file names to parse
        self.filelogname = "module-hpc"
        self.modlist = []             # installed modules names list

        self.parseArgs()
        if self.files == []:
            str = "\nThere are no module log files to parse.\n" \
                + "Files must be provided on a command line \n" \
                + "if defualt files /var/log/%s* don't exist." % self.filelogname
            print (str)
            sys.exit(0)

    def exitHelp(self):
        helpstr = "NAME\n        %s - parse log files and count how often modules were loaded\n" % self.prog \
                + "\nSYNOPSIS\n        %s [OPTION] [FILE]...\n" % self.prog \
                + "\nDESCRIPTION\n        Parse FILEs provided on a command line and find how many times modules were loaded.\n" \
                + "        If none provided, will parse /var/log/module-hpc* files. The output contains per each used\n" \
                + "        module a module name and a count of times loaded and a list of modules that were not loaded.\n\n" \
                + "        -h, --h, --help, help\n              Print usage info.\n" 
        print (helpstr)
        sys.exit(0)

    def exitError(self):
        print (self.errmsg)
        sys.exit(1)

    def parseArgs(self):
        if self.args == []:
            self.getDefaultFiles()
        elif self.args[0] in ["-h","--h","help","-help","--help"]:
            self.exitHelp()
        else:
            for i in self.args:
                if os.path.isfile(i):
                    self.files.append(i)

    def getDefaultFiles(self):
            try:
                all = os.listdir(self.basedir)
            except OSError as err:
                self.errmsg = "Error code %d: %s: '%s'" % (err.errno, err.strerror, err.filename)
                self.exitError()

            for i in all:
                if i.find(self.filelogname) == 0:
                    self.files.append(self.basedir + i)

    def countTimesLoaded(self):
        self.maxl = 0 
        # create dictionary with key:value as modulename:number_times_called
        self.count = defaultdict(int)
        self.usermod = defaultdict(int)
        for log in self.files:
            f =  open(log) 
            for i, line in enumerate(f):
                #if line.find("module-hpc") < 0: continue
                module = line.split()[-1]
                if module in self.modlist:
                    self.count[module] += 1
                else:
                    self.usermod[module] += 1
                ll = len(module)
                if ll > self.maxl:
                    self.maxl = ll

        self.countTotal = len(self.count)

        # NOTE to get only entries with more than 1 count
        # self.count = {k: v for k, v in self.count.items() if v > 1}

    def getUsedModules(self):
        self.countTimesLoaded()
        self.used = sorted(self.count.items(), key=lambda x: x[1], reverse=True)

    def getUnusedModules(self):
        blist = set(sorted(self.count.keys()))
        self.unused = [i for i in self.modlist if i not in blist]

    def printUsedModules(self):
        self.getUsedModules()
        print ("========== Total unique used modules: %d ==========" % self.countTotal)
        for i in self.used:
            print ('{sw:{width}s} {num:12d}'.format(sw=i[0], num=i[1], width=self.maxl))

    def printUnusedModules(self):
        self.getUnusedModules()
        print ("========== Total unique unused modules: %d ==========" % len(self.unused))
        for i in self.unused: 
            print (i)

    def printUserModules(self):
        print ("========== Total unique user or removed modules: %d ==========" % len(self.usermod))
        user = sorted(self.usermod.items(), key=lambda x: x[1], reverse=True)
        for i in user: 
            print ('{sw:{width}s} {num:12d}'.format(sw=i[0], num=i[1], width=self.maxl))

    def GraphUsage(self):
        import numpy as np
        import matplotlib.pyplot as plt
        name = "dot-graphs/usageStats"

        data = []
        f =  open("now") 
        for i, line in enumerate(f):
            data.append(int(line[:-1]))
        #print (data)

        #array = np.asarray(self.statsPrereqs)
        #ans = plt.hist(array, rwidth=0.8, align='left' )

        x = data
        ylog = np.log10(data)

        #plt.plot(data)
        #ax = plt.gca()
        #ax.set_yscale('log')
        #plt.show()

        bins=[0,1,2,3,4,5,6]
        plt.figure(1)
        ans=plt.hist(ylog, bins=bins,rwidth=0.8, align='left' )
        cols = ['LightSteelBlue', 'LightSkyblue', 'LightBlue', 'Gold', 'Orange','OrangeRed']
        y = ans[0]
        x = ans[1][:-1]
        yy=y/len(data)*100
        labels = ['log10=%d' % (l) for l in x]
        plt.figure(2)
        p = plt.pie(yy, pctdistance=0.7,autopct='%1.1f%%',labeldistance=1.05, startangle=0,labels=labels,colors=cols)
        plt.axis('equal')  
        plt.rcParams.update({"figure.facecolor": (1.0, 1.0, 1.0, 1.0), "axes.facecolor":(1.0, 1.0, 1.0, 0.95)})
        plt.title("Modules usage (counts are in log10)")
        plt.show()
        plt.savefig("%s.png" % name)

        #x = np.log10(data)
        #mean = np.mean(x)
        #std = np.std(x)
        #y = 1/(std * np.sqrt(2 * np.pi)) * np.exp( - (x - mean)**2 / (2 * std**2))
        #y = norm.pdf(x,mean,std)
        #plt.style.use('seaborn')
        #plt.figure(figsize = (6, 6))
        #plt.plot(x, y, color = 'black', linestyle = 'dashed')
        #plt.scatter( x, y, marker = 'o', s = 25, color = 'red')


    def run(self):
        self.GraphUsage()
        return
        self.modinfo = ModInfo()
        self.modinfo.runCheck()
        self.modlist = sorted(self.modinfo.getModNameList())
        self.printUsedModules()
        self.printUnusedModules()
        self.printUserModules()
        # DEBUG
        #print ("MOD", len(self.modlist))
        #print ("used=%s unused=%s rm=%s" % (len(self.used),len(self.unused),len(self.usermod)))

##### Run from a command line #####
if __name__ == "__main__":
    app = FileParser(sys.argv)
    app.run()

